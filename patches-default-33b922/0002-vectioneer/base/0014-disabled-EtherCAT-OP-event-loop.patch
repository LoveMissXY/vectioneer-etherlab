From 95db7abf4740c229e32364fe12a48e156691ad94 Mon Sep 17 00:00:00 2001
From: Mark Verrijt <mark.verrijt@vectioneer.com>
Date: Tue, 23 Nov 2021 16:23:31 +0100
Subject: [PATCH] disabled EtherCAT-OP event loop

---
 master/master.c | 188 ++++++++++++++++++++++++++++++++----------------
 1 file changed, 128 insertions(+), 60 deletions(-)

diff --git a/master/master.c b/master/master.c
index 81420b8e..18e1816f 100644
--- a/master/master.c
+++ b/master/master.c
@@ -42,6 +42,7 @@
 #include <linux/device.h>
 #include <linux/version.h>
 #include <linux/hrtimer.h>
+#include <linux/freezer.h>
 #include <linux/vmalloc.h>
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
@@ -104,13 +105,14 @@ const unsigned int rate_intervals[] = {
 void ec_master_clear_slave_configs(ec_master_t *);
 void ec_master_clear_domains(ec_master_t *);
 static int ec_master_idle_thread(void *);
-static int ec_master_operation_thread(void *);
+//static int ec_master_operation_thread(void *);
 #ifdef EC_EOE
 static int ec_master_eoe_thread(void *);
 #endif
 void ec_master_find_dc_ref_clock(ec_master_t *);
 void ec_master_clear_device_stats(ec_master_t *);
 void ec_master_update_device_stats(ec_master_t *);
+static size_t ecrt_master_send_impl(ec_master_t *);
 
 /*****************************************************************************/
 
@@ -1927,7 +1929,7 @@ static int ec_master_idle_thread(void *priv_data)
         if (fsm_exec) {
             ec_master_queue_datagram(master, &master->fsm_datagram);
         }
-        sent_bytes = ecrt_master_send(master);
+        sent_bytes = ecrt_master_send_impl(master);
         ec_lock_up(&master->io_sem);
 
         if (ec_fsm_master_idle(&master->fsm)) {
@@ -1956,59 +1958,91 @@ static int ec_master_idle_thread(void *priv_data)
 
 /** Master kernel thread function for OPERATION phase.
  */
-static int ec_master_operation_thread(void *priv_data)
-{
-    ec_master_t *master = (ec_master_t *) priv_data;
-
-    EC_MASTER_DBG(master, 1, "Operation thread running"
-            " with fsm interval = %u us, max data size=%zu\n",
-            master->send_interval, master->max_queue_size);
-
-    while (!kthread_should_stop()) {
-        ec_datagram_output_stats(&master->fsm_datagram);
-
-        if (master->injection_seq_rt == master->injection_seq_fsm) {
-            // output statistics
-            ec_master_output_stats(master);
-
-            // execute master & slave state machines
-            if (ec_lock_down_interruptible(&master->master_sem)) {
-                break;
-            }
-
-            if (ec_fsm_master_exec(&master->fsm)) {
-                // Inject datagrams (let the RT thread queue them, see
-                // ecrt_master_send())
-                master->injection_seq_fsm++;
-            }
-
-            // if rt_slave_requests is true and the slaves are available
-            // this will be handled by the app explicitly calling
-            // ecrt_master_exec_slave_request()
-            if (!master->rt_slave_requests || !master->rt_slaves_available) {
-                ec_master_exec_slave_fsms(master);
-            }
-
-            ec_lock_up(&master->master_sem);
-        }
-
-#ifdef EC_USE_HRTIMER
-        // the op thread should not work faster than the sending RT thread
-        ec_master_nanosleep(master->send_interval * 1000);
-#else
-        if (ec_fsm_master_idle(&master->fsm)) {
-            set_current_state(TASK_INTERRUPTIBLE);
-            schedule_timeout(1);
-        }
-        else {
-            schedule();
-        }
-#endif
-    }
-
-    EC_MASTER_DBG(master, 1, "Master OP thread exiting...\n");
-    return 0;
-}
+//ktime_t ec_master_nanosleep_test(struct hrtimer_sleeper *t, ktime_t ideal_time, const unsigned long nsecs)
+//{
+//    t->task = current;
+//    ideal_time = ktime_add_ns(ideal_time, nsecs);
+//    hrtimer_set_expires(&t->timer, ideal_time);
+//
+//    do {
+//        set_current_state(TASK_INTERRUPTIBLE);
+//        hrtimer_start_expires(&t->timer, HRTIMER_MODE_ABS);
+//
+//        if (likely(t->task))
+//            freezable_schedule();
+//
+//        hrtimer_cancel(&t->timer);
+//
+//    } while (t->task && !signal_pending(current));
+//    __set_current_state(TASK_RUNNING);
+//
+//    return ideal_time;
+//}
+//
+//static int ec_master_operation_thread(void *priv_data)
+//{
+//
+//    ec_master_t *master = (ec_master_t *) priv_data;
+//
+//    struct hrtimer_sleeper t;
+//    ktime_t ideal_time;
+//    s64 actual_time;
+//    hrtimer_init_sleeper(&t, CLOCK_MONOTONIC, HRTIMER_MODE_ABS, current);
+//
+//    ideal_time = t.timer.base->get_time();
+//
+//    EC_MASTER_DBG(master, 1, "Operation thread running"
+//            " with fsm interval = %u us, max data size=%zu\n",
+//            master->send_interval, master->max_queue_size);
+//
+//    while (!kthread_should_stop()) {
+//       //ideal_time = ec_master_nanosleep_test(&t, ideal_time, master->send_interval * 10000);
+//
+//        ec_datagram_output_stats(&master->fsm_datagram);
+//
+//        if (master->injection_seq_rt == master->injection_seq_fsm) {
+//            // output statistics
+//            ec_master_output_stats(master);
+//
+//            // execute master & slave state machines
+//            if (ec_lock_down_interruptible(&master->master_sem)) {
+//                break;
+//            }
+//
+//            if (ec_fsm_master_exec(&master->fsm)) {
+//                // Inject datagrams (let the RT thread queue them, see
+//                // ecrt_master_send())
+//                master->injection_seq_fsm++;
+//            }
+//
+//            // if rt_slave_requests is true and the slaves are available
+//            // this will be handled by the app explicitly calling
+//            // ecrt_master_exec_slave_request()
+//            if (!master->rt_slave_requests || !master->rt_slaves_available) {
+//                ec_master_exec_slave_fsms(master);
+//            }
+//
+//            ec_lock_up(&master->master_sem);
+//        }
+//
+//#ifdef EC_USE_HRTIMER
+//        // the op thread should not work faster than the sending RT thread
+//        // ec_master_nanosleep(master->send_interval * 1000 / 4);
+//        ideal_time = ec_master_nanosleep_test(&t, ideal_time, master->send_interval * 1000 / 2);
+//#else
+//        if (ec_fsm_master_idle(&master->fsm)) {
+//            set_current_state(TASK_INTERRUPTIBLE);
+//            schedule_timeout(1);
+//        }
+//        else {
+//            schedule();
+//        }
+//#endif
+//    }
+//
+//    EC_MASTER_DBG(master, 1, "Master OP thread exiting...\n");
+//    return 0;
+//}
 
 /*****************************************************************************/
 
@@ -2883,12 +2917,12 @@ int ecrt_master_activate(ec_master_t *master)
         ec_master_eoe_start(master);
     }
 #endif
-    ret = ec_master_thread_start(master, ec_master_operation_thread,
+    /*ret = ec_master_thread_start(master, ec_master_operation_thread,
                 "EtherCAT-OP");
     if (ret < 0) {
         EC_MASTER_ERR(master, "Failed to start master thread!\n");
         return ret;
-    }
+    }*/
 
     /* Allow scanning after a topology change. */
     master->allow_scan = 1;
@@ -2953,7 +2987,7 @@ void ecrt_master_deactivate(ec_master_t *master)
         return;
     }
 
-    ec_master_thread_stop(master);
+//    ec_master_thread_stop(master);
 #ifdef EC_EOE
     ec_master_eoe_stop(master);
 #endif
@@ -3001,7 +3035,7 @@ void ecrt_master_deactivate(ec_master_t *master)
 
 /*****************************************************************************/
 
-size_t ecrt_master_send(ec_master_t *master)
+static size_t ecrt_master_send_impl(ec_master_t *master)
 {
     ec_datagram_t *datagram, *n;
     ec_device_index_t dev_idx;
@@ -3050,6 +3084,40 @@ size_t ecrt_master_send(ec_master_t *master)
 
 /*****************************************************************************/
 
+size_t ecrt_master_send(ec_master_t *master)
+{
+  ec_datagram_output_stats(&master->fsm_datagram);
+
+  if (master->injection_seq_rt == master->injection_seq_fsm) {
+    // output statistics
+    ec_master_output_stats(master);
+
+    // execute master & slave state machines
+    //if (ec_lock_down_interruptible(&master->master_sem)) {
+    //    return sent_bytes;
+    //}
+
+    if (ec_fsm_master_exec(&master->fsm)) {
+      // Inject datagrams (let the RT thread queue them, see
+      // ecrt_master_send())
+      master->injection_seq_fsm++;
+    }
+
+    // if rt_slave_requests is true and the slaves are available
+    // this will be handled by the app explicitly calling
+    // ecrt_master_exec_slave_request()
+    if (!master->rt_slave_requests || !master->rt_slaves_available) {
+      ec_master_exec_slave_fsms(master);
+    }
+
+    //ec_lock_up(&master->master_sem);
+  }
+
+  return ecrt_master_send_impl(master);
+}
+
+/*****************************************************************************/
+
 void ecrt_master_receive(ec_master_t *master)
 {
     unsigned int dev_idx;
@@ -3114,7 +3182,7 @@ size_t ecrt_master_send_ext(ec_master_t *master)
         ec_master_queue_datagram(master, datagram);
     }
     ec_lock_up(&master->ext_queue_sem);
-
+    
     return ecrt_master_send(master);
 }
 
-- 
2.25.1

